<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mindmap từ văn bản – gõ để vẽ</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #0f172a;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --node-w: 220px;
      --node-h: auto;
      --col-gap: 120px; /* khoảng cách ngang giữa các cấp */
      --row-gap: 28px;  /* khoảng cách dọc tối thiểu giữa các nút */
      --radius: 14px;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
      --left-panel-width: 420px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, #1f2937 0%, var(--bg) 60%);
      color: var(--text);
    }

    .app {
      display: grid;
      grid-template-columns: var(--left-panel-width) 1fr;
      gap: 16px;
      height: 100vh;
      padding: 16px;
      transition: grid-template-columns 0.4s ease;
    }

    .left {
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: transform 0.4s ease, opacity 0.3s ease;
      position: relative;
    }

    /* === THAY ĐỔI KHI ĐÓNG PANEL === */
    .app.panel-closed {
      grid-template-columns: 0px 1fr;
    }
    .app.panel-closed .left {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }

    h1 {
      font-size: 18px;
      margin: 0 0 2px 0;
      font-weight: 650;
      letter-spacing: .2px;
      color: #f1f5f9;
    }

    .help { color: var(--muted); font-size: 12px; line-height: 1.5; }

    textarea {
      width: 100%;
      height: 100%;
      resize: none;
      padding: 14px 14px 18px 14px;
      border-radius: 16px;
      border: 1px solid #1f2a44;
      background: linear-gradient(180deg, #0c1425, #0b1220);
      color: var(--text);
      outline: none;
      box-shadow: var(--shadow);
      line-height: 1.6;
      caret-color: var(--accent);
      tab-size: 2;
    }

    .right {
      position: relative;
      border-radius: 16px;
      background: linear-gradient(180deg, #0c1425, #0b1220);
      border: 1px solid #1f2a44;
      overflow: hidden;
      box-shadow: var(--shadow);
      cursor: grab;
    }
    .right:active { cursor: grabbing; }

    .canvas {
      position: relative;
      min-width: 100%;
      min-height: 100%;
      transform-origin: 0 0;
    }

    .node {
      position: absolute;
      width: var(--node-w);
      max-width: var(--node-w);
      padding: 10px 12px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      color: #0b1220;
      font-weight: 600;
      line-height: 1.45;
      word-wrap: break-word;
      overflow-wrap: anywhere;
      transition: transform .12s ease;
    }
    .node:hover { transform: translateY(-1px) scale(1.01); }

    .svg-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn {
      background: #0a1222;
      color: var(--text);
      border: 1px solid #1f2a44;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .btn:hover{ border-color:#2a3b63 }

    /* === NÚT ĐÓNG/MỞ PANEL === */
    #panel-toggle-btn {
        position: fixed;
        top: 20px;
        left: calc(var(--left-panel-width) + 4px);
        z-index: 100;
        width: 28px;
        height: 28px;
        background: #1f2937;
        color: var(--text);
        border: 1px solid #2a3b63;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        transition: left 0.4s ease, transform 0.3s ease;
    }

    .app.panel-closed + #panel-toggle-btn {
        left: 10px;
        transform: scaleX(-1);
    }
    /* === KẾT THÚC CSS MỚI === */


    @media (max-width: 1000px) {
      .app { grid-template-columns: 1fr; height: auto; }
      .right { height: 70vh; }
      #panel-toggle-btn { display: none; } /* Ẩn nút trên mobile */
    }
  </style>
</head>
<body>
  <div class="app" id="app-container">
    <div class="left">
      <div class="toolbar">
        <h1>Mindmap từ văn bản</h1>
        <button class="btn" id="btnDownload">Tải Mindmap</button>
        <button class="btn" id="btnImport">Nhập Mindmap</button>
        <input type="file" id="fileInput" accept=".txt" style="display: none;">
      </div>
      <div class="help">
        • Mỗi <b>dòng</b> là một nút. Số <b>dấu cách đầu dòng</b> = cấp độ.<br/>
        • Gõ / xóa: sơ đồ <b>cập nhật ngay</b>. Dùng <kbd>Tab</kbd> để thụt đầu dòng.<br/>
        • Lăn chuột để <b>phóng to/thu nhỏ</b>, kéo chuột để <b>di chuyển</b>.<br/>
      </div>
      <textarea id="editor" spellcheck="false" placeholder="Nhập nội dung ở đây...\nVí dụ:\nChủ đề\n  Nhánh 1\n    Ý 1.1\n    Ý 1.2\n  Nhánh 2\n    Ý 2.1\n      Chi tiết 2.1.1\n  Nhánh 3"></textarea>
    </div>

    <div class="right" id="viewport">
      <div class="canvas" id="canvas">
        <svg class="svg-layer" id="wires"></svg>
      </div>
    </div>
  </div>

  <button id="panel-toggle-btn">«</button>

  <script>
    const editor = document.getElementById('editor');
    const canvas = document.getElementById('canvas');
    const wires = document.getElementById('wires');
    const viewport = document.getElementById('viewport');
    const btnDownload = document.getElementById('btnDownload');
    const btnImport = document.getElementById('btnImport');
    const fileInput = document.getElementById('fileInput');

    // === JAVASCRIPT MỚI CHO NÚT ĐÓNG/MỞ ===
    const appContainer = document.getElementById('app-container');
    const panelToggleBtn = document.getElementById('panel-toggle-btn');

    panelToggleBtn.addEventListener('click', () => {
        appContainer.classList.toggle('panel-closed');
    });
    // === KẾT THÚC JAVASCRIPT MỚI ===

    let scale = 1;
    let panX = 40;
    let panY = 40;
    let isPanning = false;
    let startPanX = 0;
    let startPanY = 0;

    function applyTransform() {
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    viewport.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      const mouseBeforeZoomX = (mouseX - panX) / scale;
      const mouseBeforeZoomY = (mouseY - panY) / scale;
      
      const delta = -e.deltaY * 0.001;
      const newScale = Math.max(0.2, Math.min(3, scale + delta));
      
      panX = mouseX - mouseBeforeZoomX * newScale;
      panY = mouseY - mouseBeforeZoomY * newScale;
      scale = newScale;
      
      applyTransform();
    });

    viewport.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        isPanning = true;
        startPanX = e.clientX - panX;
        startPanY = e.clientY - panY;
        viewport.style.cursor = 'grabbing';
    });

    window.addEventListener('mouseup', () => {
        isPanning = false;
        viewport.style.cursor = 'grab';
    });
    
    window.addEventListener('mousemove', (e) => {
        if (isPanning) {
            panX = e.clientX - startPanX;
            panY = e.clientY - startPanY;
            applyTransform();
        }
    });

    editor.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const val = editor.value;
        editor.value = val.substring(0, start) + '  ' + val.substring(end);
        editor.selectionStart = editor.selectionEnd = start + 2;
        triggerUpdate();
      }
    });

    btnDownload.addEventListener('click', () => {
        const text = editor.value;
        const blob = new Blob([text], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'mindmap.txt';
        a.click();
        URL.revokeObjectURL(a.href);
    });

    btnImport.addEventListener('click', () => {
        fileInput.click();
    });

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            editor.value = event.target.result;
            triggerUpdate();
        };
        reader.readAsText(file);
        fileInput.value = '';
    });

    function parseLines(text){
      return text.split(/\r?\n/)
        .map((raw, idx) => {
          const match = raw.match(/^(\s*)(.*)$/);
          const indent = match ? match[1] : '';
          const content = match ? match[2] : raw;
          const spaces = indent.replace(/\t/g, '  ');
          const level = Math.floor(spaces.length / 2);
          return { id: idx, level, text: content.trim(), raw };
        })
        .filter(n => n.text.length > 0);
    }

    function buildTree(nodes){
      const root = { id: 'root', level: -1, text: 'ROOT', children: [] };
      const stack = [root];
      nodes.forEach(n => {
        while (stack.length && stack[stack.length-1].level >= n.level) stack.pop();
        const parent = stack[stack.length-1] || root;
        const node = { ...n, children: [] };
        parent.children.push(node);
        stack.push(node);
      });
      return root;
    }
    
    function layoutTree(root){
      const colWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-w')) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--col-gap'));
      const rowGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--row-gap'));
      const positions = new Map();
      const levelHeights = new Map();

      function calculateY(node, currentY) {
          const nodeHeight = 20 + Math.ceil(node.text.length / 25) * 24 + 10;
          let y = currentY;
          if (levelHeights.has(node.level) && levelHeights.get(node.level) > y) {
              y = levelHeights.get(node.level);
          }
          const x = node.level * colWidth;
          positions.set(node.id, { x, y, w: 220, h: nodeHeight });
          let childY = y;
          if (node.children.length > 1) {
            const childrenHeight = node.children.reduce((acc, child) => acc + (20 + Math.ceil(child.text.length / 25) * 24 + 10) + rowGap, 0) - rowGap;
            const parentPos = positions.get(node.id);
            parentPos.y = y + childrenHeight / 2 - parentPos.h / 2;
            positions.set(node.id, parentPos);
          }
          for (const child of node.children) {
              childY = calculateY(child, childY);
          }
          const newY = childY > y ? childY : y + nodeHeight + rowGap;
          levelHeights.set(node.level, newY);
          return newY;
      }
      
      let currentY = 0;
      for(const child of root.children){
          currentY = calculateY(child, currentY);
      }
      let maxX = 0, maxY = 0;
      positions.forEach(p => { 
        maxX = Math.max(maxX, p.x + p.w); 
        maxY = Math.max(maxY, p.y + p.h); 
      });
      return { positions, width: maxX + colWidth, height: maxY + rowGap * 2 };
    }
    
    const BASE_HUES = [210, 160, 40, 300, 260, 70];

    function hslForLevel(level, branchIndex){
      const hue = BASE_HUES[branchIndex % BASE_HUES.length];
      const sat = 85;
      const light = Math.max(40, 95 - level * 12);
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    function draw(root, layout){
      const { positions, width, height } = layout;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      // === PHẦN SỬA LỖI ===
      // Gán kích thước CỐ ĐỊNH cho lớp vẽ SVG để nó không bị co dãn
      wires.setAttribute('width', width);
      wires.setAttribute('height', height);
      // === KẾT THÚC SỬA LỖI ===

      wires.setAttribute('viewBox', `0 0 ${width} ${height}`);
      wires.innerHTML = '';
      const fragment = document.createDocumentFragment();
      [...canvas.querySelectorAll('.node')].forEach(n => n.remove());

      function render(node, parent, branchIndex){
        if (node.id === 'root') {
             node.children.forEach((child, index) => render(child, node, index));
             return;
        }
        const p = positions.get(node.id);
        const el = document.createElement('div');
        el.className = 'node';
        el.style.left = p.x + 'px';
        el.style.top = p.y + 'px';
        el.style.height = p.h + 'px';
        el.style.background = hslForLevel(node.level, branchIndex);
        el.textContent = node.text;
        fragment.appendChild(el);
        if (parent && parent.id !== 'root'){
          const a = positions.get(parent.id);
          const x1 = a.x + a.w;
          const y1 = a.y + a.h / 2;
          const x2 = p.x;
          const y2 = p.y + p.h / 2;
          const dx = Math.max(40, (x2 - x1) / 2);
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', 'rgba(148,163,184,.6)');
          path.setAttribute('stroke-width', '2');
          path.setAttribute('stroke-linecap', 'round');
          wires.appendChild(path);
        }
        node.children.forEach(child => render(child, node, branchIndex));
      }
      render(root, null, 0);
      canvas.insertBefore(fragment, wires);
    }

    let raf;
    function triggerUpdate(){
      if (raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        const nodes = parseLines(editor.value);
        const tree = buildTree(nodes);
        const layout = layoutTree(tree);
        draw(tree, layout);
      });
    }

    editor.addEventListener('input', triggerUpdate);

    applyTransform();
    triggerUpdate();
  </script>
</body>
</html>