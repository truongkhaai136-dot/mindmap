<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mindmap từ văn bản – Chế độ Thuyết trình</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #0f172a;
      --text: #e2e8f0;
      --text-dark: #0b1220;
      --text-light: #f1f5f9;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --node-w: 220px;
      --node-h: auto;
      --col-gap: 120px;
      --row-gap: 28px;
      --radius: 14px;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
      --left-panel-width: 420px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, #1f2937 0%, var(--bg) 60%);
      color: var(--text);
    }
    .app { display: grid; grid-template-columns: var(--left-panel-width) 1fr; gap: 16px; height: 100vh; padding: 16px; transition: grid-template-columns 0.4s ease; }
    .left { display: flex; flex-direction: column; gap: 12px; transition: transform 0.4s ease, opacity 0.3s ease; position: relative; }
    .app.panel-closed { grid-template-columns: 0px 1fr; }
    .app.panel-closed .left { transform: translateX(-100%); opacity: 0; pointer-events: none; }
    h1 { font-size: 18px; margin: 0 0 2px 0; font-weight: 650; letter-spacing: .2px; color: #f1f5f9; }
    .help { color: var(--muted); font-size: 12px; line-height: 1.5; }
    textarea { width: 100%; height: 100%; resize: none; padding: 14px 14px 18px 14px; border-radius: 16px; border: 1px solid #1f2a44; background: linear-gradient(180deg, #0c1425, #0b1220); color: var(--text); outline: none; box-shadow: var(--shadow); line-height: 1.6; caret-color: var(--accent); tab-size: 2; }
    .right { 
      position: relative; 
      border-radius: 16px; 
      background: linear-gradient(180deg, #0c1425, #0b1220); 
      border: 1px solid #1f2a44; 
      overflow: hidden; 
      box-shadow: var(--shadow); 
      cursor: grab; 
      /* CSS cho hình nền */
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    .right:active { cursor: grabbing; }
    .canvas { position: relative; min-width: 100%; min-height: 100%; transform-origin: 0 0; }
    .node { position: absolute; width: var(--node-w); max-width: var(--node-w); padding: 10px 12px; border-radius: var(--radius); border: 1px solid rgba(255,255,255,.08); box-shadow: 0 6px 18px rgba(0,0,0,.35); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); color: var(--text-dark); font-weight: 600; line-height: 1.45; word-wrap: break-word; overflow-wrap: anywhere; transition: transform .12s ease, opacity .3s ease, background .3s ease; }
    .node:hover { transform: translateY(-1px) scale(1.01); }
    .node.presentation-clickable { cursor: pointer; }
    .svg-layer { position: absolute; inset: 0; pointer-events: none; }
    .toolbar { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .btn { background: #0a1222; color: var(--text); border: 1px solid #1f2a44; padding: 8px 10px; border-radius: 10px; font-size: 12px; cursor: pointer; }
    .btn:hover{ border-color:#2a3b63 }
    .btn.active { background-color: var(--accent); color: var(--bg); border-color: var(--accent); }
    #panel-toggle-btn { position: fixed; top: 20px; left: calc(var(--left-panel-width) + 4px); z-index: 100; width: 28px; height: 28px; background: #1f2937; color: var(--text); border: 1px solid #2a3b63; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: left 0.4s ease, transform 0.3s ease; }
    .app.panel-closed + #panel-toggle-btn { left: 10px; transform: scaleX(-1); }
    
    /* CSS cho ảnh di động */
    #image-container {
      position: absolute;
      display: none;
      top: 100px;
      left: 100px;
      width: 200px;
      height: auto;
      cursor: move;
      z-index: 10;
      border: 2px dashed var(--accent);
      border-radius: 8px;
    }
    #movable-image {
      width: 100%;
      height: 100%;
      display: block;
      pointer-events: none; /* Quan trọng để sự kiện chuột đi qua ảnh */
    }
    .resize-handle {
      position: absolute;
      width: 15px;
      height: 15px;
      background: var(--accent);
      right: -7.5px;
      bottom: -7.5px;
      border-radius: 50%;
      cursor: nwse-resize;
      border: 2px solid var(--bg);
    }

    @media (max-width: 1000px) { .app { grid-template-columns: 1fr; height: auto; } .right { height: 70vh; } #panel-toggle-btn { display: none; } }
  </style>
</head>
<body>
  <div class="app" id="app-container">
    <div class="left">
      <div class="toolbar">
        <h1>Mindmap từ văn bản</h1>
        <button class="btn" id="btnDownload">Tải Mindmap</button>
        <button class="btn" id="btnImport">Nhập Mindmap</button>
        <button class="btn" id="btnPresent">Thuyết trình</button>
        <!-- Nút mới cho tính năng ảnh -->
        <button class="btn" id="btnChangeBg">Đổi nền</button>
        <button class="btn" id="btnAddImage">Thêm ảnh</button>
        
        <!-- Input ẩn cho tải file -->
        <input type="file" id="fileInput" accept=".txt" style="display: none;">
        <input type="file" id="bgInput" accept="image/*" style="display: none;">
        <input type="file" id="imageInput" accept="image/*" style="display: none;">
      </div>
      <div class="help">
        • Mỗi <b>dòng</b> là một nút. Số <b>dấu cách đầu dòng</b> = cấp độ.<br/>
        • Gõ / xóa: sơ đồ <b>cập nhật ngay</b>. Dùng <kbd>Tab</kbd> để thụt đầu dòng.<br/>
        • Lăn chuột để <b>phóng to/thu nhỏ</b>, kéo chuột để <b>di chuyển</b>.<br/>
        • Với ảnh thêm vào: Lăn chuột để <b>phóng to/nhỏ</b>, kéo góc để <b>đổi cỡ</b>.
      </div>
      <textarea id="editor" spellcheck="false">Học Tiếng Anh
  Học Ngữ Pháp
    Thì Hiện tại đơn
    Thì Quá khứ đơn
      Chi tiết thì
  Học Từ Vựng
    Chủ đề Gia đình
    Chủ đề Công việc
  Học Phát Âm
    Nguyên âm
    Phụ âm</textarea>
    </div>
    <div class="right" id="viewport">
      <!-- Container cho ảnh di động -->
      <div id="image-container">
        <img id="movable-image" src="">
        <div class="resize-handle"></div>
      </div>
      <div class="canvas" id="canvas">
        <svg class="svg-layer" id="wires"></svg>
      </div>
    </div>
  </div>
  <button id="panel-toggle-btn">«</button>
  <script>
    const editor = document.getElementById('editor');
    const canvas = document.getElementById('canvas');
    const wires = document.getElementById('wires');
    const viewport = document.getElementById('viewport');
    const btnDownload = document.getElementById('btnDownload');
    const btnImport = document.getElementById('btnImport');
    const fileInput = document.getElementById('fileInput');
    const btnPresent = document.getElementById('btnPresent');
    const appContainer = document.getElementById('app-container');
    const panelToggleBtn = document.getElementById('panel-toggle-btn');

    // --- START: Biến và DOM elements cho tính năng ảnh ---
    const btnChangeBg = document.getElementById('btnChangeBg');
    const bgInput = document.getElementById('bgInput');
    const btnAddImage = document.getElementById('btnAddImage');
    const imageInput = document.getElementById('imageInput');
    const imageContainer = document.getElementById('image-container');
    const movableImage = document.getElementById('movable-image');
    const resizeHandle = document.querySelector('.resize-handle');
    // --- END: Biến và DOM elements cho tính năng ảnh ---

    let scale = 1, panX = 40, panY = 40;
    let isPanning = false, startPanX = 0, startPanY = 0;
    let presentationMode = false;
    let mindmapTree = {};

    // --- START: COLOR LOGIC ---
    const ROOT_NODE_PALETTE = ['#d586f4','#c3e9cc','#f3a88f','#a6abe7','#eedc96','#f6f3ce','#aae496'];
    const MAIN_BRANCH_COLORS = ['#B0E0E6','#FFFACD','#D8BFD8','#FFDAB9','#AAF0D1','#EEDFCC','#FFF5E1'];
    let rootNodeColor = ROOT_NODE_PALETTE[Math.floor(Math.random()*ROOT_NODE_PALETTE.length)];

    function hexToHsl(hex) {
      if (!hex) return null;
      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!result) return null;
      let r = parseInt(result[1], 16) / 255, g = parseInt(result[2], 16) / 255, b = parseInt(result[3], 16) / 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h = 0, s = 0, l = (max + min) / 2;
      if (max == min) { h = s = 0; } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; }
        h /= 6;
      }
      return { h: h * 360, s: s, l: l };
    }
    // --- END: COLOR LOGIC ---
    
    panelToggleBtn.addEventListener('click', () => appContainer.classList.toggle('panel-closed'));

    btnPresent.addEventListener('click', () => {
        presentationMode = !presentationMode;
        btnPresent.classList.toggle('active', presentationMode);
        function setVisibility(node, level) {
            node.isVisible = presentationMode ? level <= 0 : true;
            node.children.forEach(child => setVisibility(child, level + 1));
        }
        setVisibility(mindmapTree, -1);
        triggerUpdate(false);
    });

    function applyTransform() { canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`; }

    viewport.addEventListener('wheel', (e) => {
      // Ngăn phóng to/thu nhỏ canvas nếu đang cuộn trên ảnh di động
      if (e.target.closest('#image-container')) return;
      e.preventDefault();
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;
      const mouseBeforeZoomX = (mouseX - panX) / scale, mouseBeforeZoomY = (mouseY - panY) / scale;
      const newScale = Math.max(0.2, Math.min(3, scale - e.deltaY * 0.001));
      panX = mouseX - mouseBeforeZoomX * newScale;
      panY = mouseY - mouseBeforeZoomY * newScale;
      scale = newScale;
      applyTransform();
    });

    viewport.addEventListener('mousedown', (e) => {
        // Ngăn di chuyển canvas nếu đang tương tác với ảnh di động
        if (e.target.closest('#image-container') || e.button !== 0) return;
        isPanning = true;
        startPanX = e.clientX - panX;
        startPanY = e.clientY - panY;
        viewport.style.cursor = 'grabbing';
    });
    window.addEventListener('mouseup', () => { isPanning = false; viewport.style.cursor = 'grab'; });
    window.addEventListener('mousemove', (e) => {
        if (isPanning) { panX = e.clientX - startPanX; panY = e.clientY - startPanY; applyTransform(); }
    });

    editor.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = editor.selectionStart, end = editor.selectionEnd;
        editor.value = editor.value.substring(0, start) + '  ' + editor.value.substring(end);
        editor.selectionStart = editor.selectionEnd = start + 2;
        triggerUpdate();
      }
    });

    btnDownload.addEventListener('click', () => {
        const blob = new Blob([editor.value], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'mindmap.txt';
        a.click();
        URL.revokeObjectURL(a.href);
    });

    btnImport.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => { editor.value = event.target.result; triggerUpdate(); };
        reader.readAsText(file);
        fileInput.value = '';
    });

    // --- START: LOGIC CHO TÍNH NĂNG ẢNH ---

    // 1. Đổi hình nền
    btnChangeBg.addEventListener('click', () => bgInput.click());
    bgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            viewport.style.backgroundImage = `url('${event.target.result}')`;
        };
        reader.readAsDataURL(file);
        bgInput.value = '';
    });

    // 2. Thêm ảnh di động
    btnAddImage.addEventListener('click', () => imageInput.click());
    imageInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            movableImage.src = event.target.result;
            imageContainer.style.display = 'block';
        };
        reader.readAsDataURL(file);
        imageInput.value = '';
    });

    // 3. Logic di chuyển, thay đổi kích thước, phóng to/thu nhỏ ảnh
    let isDragging = false, isResizing = false;
    let imgOffsetX, imgOffsetY;
    
    imageContainer.addEventListener('mousedown', (e) => {
        // Chỉ bắt đầu kéo nếu click vào container, không phải handle resize
        if (e.target === resizeHandle) return;
        e.stopPropagation(); // Ngăn canvas di chuyển
        isDragging = true;
        imgOffsetX = e.clientX - imageContainer.offsetLeft;
        imgOffsetY = e.clientY - imageContainer.offsetTop;
    });

    resizeHandle.addEventListener('mousedown', (e) => {
        e.stopPropagation(); // Ngăn canvas di chuyển
        isResizing = true;
        // Lưu vị trí chuột và kích thước ban đầu
        imgOffsetX = e.clientX;
        imgOffsetY = e.clientY;
        const initialWidth = imageContainer.offsetWidth;
        const initialHeight = imageContainer.offsetHeight;

        window.addEventListener('mousemove', resizeImage);
        window.addEventListener('mouseup', stopResize);

        function resizeImage(event) {
            if (isResizing) {
                const dx = event.clientX - imgOffsetX;
                const dy = event.clientY - imgOffsetY;
                imageContainer.style.width = `${initialWidth + dx}px`;
                imageContainer.style.height = `${initialHeight + dy}px`;
            }
        }

        function stopResize() {
            isResizing = false;
            window.removeEventListener('mousemove', resizeImage);
            window.removeEventListener('mouseup', stopResize);
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (isDragging) {
            imageContainer.style.left = `${e.clientX - imgOffsetX}px`;
            imageContainer.style.top = `${e.clientY - imgOffsetY}px`;
        }
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
    });

    // Phóng to/thu nhỏ ảnh bằng lăn chuột
    imageContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const currentWidth = imageContainer.offsetWidth;
        const scaleFactor = e.deltaY < 0 ? 1.1 : 0.9; // Phóng to nếu cuộn lên, thu nhỏ nếu cuộn xuống
        imageContainer.style.width = `${currentWidth * scaleFactor}px`;
        // Giữ tỷ lệ khung hình
        imageContainer.style.height = 'auto'; 
    });


    // --- END: LOGIC CHO TÍNH NĂNG ẢNH ---


    function parseLines(text){
      return text.split(/\r?\n/).map((raw, idx) => {
          const match = raw.match(/^(\s*)(.*)$/);
          const level = Math.floor((match ? match[1] : '').replace(/\t/g, '  ').length / 2);
          const content = (match ? match[2] : raw).trim();
          return { id: idx, level, text: content };
        }).filter(n => n.text.length > 0);
    }

    function buildTree(nodes){
      const root = { id: 'root', level: -1, children: [], isVisible: true };
      const stack = [root];
      nodes.forEach(n => {
        while (stack.length && stack[stack.length-1].level >= n.level) stack.pop();
        const parent = stack[stack.length-1] || root;
        const node = { ...n, children: [], isVisible: !presentationMode || n.level < 1 };
        parent.children.push(node);
        stack.push(node);
      });
      return root;
    }
    
    function layoutTree(root){
      const colWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-w')) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--col-gap'));
      const rowGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--row-gap'));
      const positions = new Map(), levelHeights = new Map();

      function calculateY(node, currentY) {
          const nodeHeight = 20 + Math.ceil(node.text.length / 25) * 24 + 10;
          let y = currentY;
          if (levelHeights.has(node.level) && levelHeights.get(node.level) > y) y = levelHeights.get(node.level);
          positions.set(node.id, { x: node.level * colWidth, y, w: 220, h: nodeHeight });
          
          let childY = y;
          const visibleChildren = node.children.filter(c => c.isVisible);
          if (visibleChildren.length > 0) {
              const childrenTotalHeight = visibleChildren.reduce((acc, child) => {
                  const childHeight = 20 + Math.ceil(child.text.length / 25) * 24 + 10;
                  return acc + childHeight + rowGap;
              }, -rowGap);
              const parentPos = positions.get(node.id);
              if (childrenTotalHeight > nodeHeight) {
                  parentPos.y = y + childrenTotalHeight / 2 - parentPos.h / 2;
                  positions.set(node.id, parentPos);
              }
          }
          for (const child of visibleChildren) childY = calculateY(child, childY);
          const newY = childY > y ? childY : y + nodeHeight + rowGap;
          levelHeights.set(node.level, newY);
          return newY;
      }
      let currentY = 0;
      for(const child of root.children.filter(c => c.isVisible)) currentY = calculateY(child, currentY);
      let maxX = 0, maxY = 0;
      positions.forEach(p => { maxX = Math.max(maxX, p.x + p.w); maxY = Math.max(maxY, p.y + p.h); });
      return { positions, width: maxX + colWidth, height: maxY + rowGap * 2 };
    }
    
    function draw(root, layout){
      const { positions, width, height } = layout;
      canvas.style.width = `${width}px`; canvas.style.height = `${height}px`;
      wires.setAttribute('width', width); wires.setAttribute('height', height); wires.setAttribute('viewBox', `0 0 ${width} ${height}`);
      wires.innerHTML='';
      const fragment=document.createDocumentFragment();
      [...canvas.querySelectorAll('.node')].forEach(n=>n.remove());

      function render(node, parent, branchIndex, baseBranchColor){
        if(node.id === 'root'){
          node.children.forEach((child, index) => render(child, node, index, null));
          return;
        }
        if(!node.isVisible) return;
        
        let currentBaseColor = baseBranchColor;
        let finalNodeColor = currentBaseColor;
        
        if(node.level === 0){
            finalNodeColor = rootNodeColor;
        } else if (node.level === 1) {
            currentBaseColor = MAIN_BRANCH_COLORS[branchIndex % MAIN_BRANCH_COLORS.length];
            finalNodeColor = currentBaseColor;
        } else if (node.level > 1) {
            const baseHsl = hexToHsl(currentBaseColor);
            if (baseHsl) {
                let newLightness = baseHsl.l * 100 - (node.level - 1) * 10;
                newLightness = Math.max(25, newLightness);
                finalNodeColor = `hsl(${baseHsl.h}, ${baseHsl.s * 100}%, ${newLightness}%)`;
            }
        }

        const p = positions.get(node.id);
        const el = document.createElement('div');
        el.className = 'node';
        el.style.left = `${p.x}px`; el.style.top = `${p.y}px`; el.style.height = `${p.h}px`;
        el.style.background = finalNodeColor;
        el.textContent = node.text;

        const finalHsl = hexToHsl(finalNodeColor);
        if(finalHsl && finalHsl.l < 0.65) el.style.color = 'var(--text-light)';
        else el.style.color = 'var(--text-dark)';
        
        if (node.level === 0) { el.style.fontSize = '18px'; el.style.fontWeight = '900'; }
        
        if (presentationMode && node.children.some(c => !c.isVisible)) {
            el.classList.add('presentation-clickable');
            el.onclick = () => { node.children.forEach(c => c.isVisible = true); triggerUpdate(false); };
        }
        
        fragment.appendChild(el);
        if(parent && parent.id!=='root' && parent.isVisible){
            const a = positions.get(parent.id), p_pos=positions.get(node.id);
            const [x1, y1, x2, y2] = [a.x+a.w, a.y+a.h/2, p_pos.x, p_pos.y+p_pos.h/2];
            const dx = Math.max(40, (x2 - x1) / 2);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke','rgba(148,163,184,.6)');
            path.setAttribute('stroke-width','2');
            path.setAttribute('stroke-linecap','round');
            wires.appendChild(path);
        }
        
        node.children.forEach((child, index) => render(child, node, index, currentBaseColor));
      }
      render(root, null, 0, null);
      canvas.insertBefore(fragment, wires);
    }

    let raf;
    function triggerUpdate(reparse = true){
      if (raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        if (reparse) { mindmapTree = buildTree(parseLines(editor.value)); }
        draw(mindmapTree, layoutTree(mindmapTree));
      });
    }

    editor.addEventListener('input', () => triggerUpdate());
    applyTransform();
    triggerUpdate();
  </script>
</body>
</html>
