<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mindmap từ văn bản – Chế độ Thuyết trình</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #0f172a;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --node-w: 220px;
      --node-h: auto;
      --col-gap: 120px; /* khoảng cách ngang giữa các cấp */
      --row-gap: 28px;  /* khoảng cách dọc tối thiểu giữa các nút */
      --radius: 14px;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
      --left-panel-width: 420px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, #1f2937 0%, var(--bg) 60%);
      color: var(--text);
    }

    .app {
      display: grid;
      grid-template-columns: var(--left-panel-width) 1fr;
      gap: 16px;
      height: 100vh;
      padding: 16px;
      transition: grid-template-columns 0.4s ease;
    }

    .left {
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: transform 0.4s ease, opacity 0.3s ease;
      position: relative;
    }

    .app.panel-closed {
      grid-template-columns: 0px 1fr;
    }
    .app.panel-closed .left {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }

    h1 {
      font-size: 18px;
      margin: 0 0 2px 0;
      font-weight: 650;
      letter-spacing: .2px;
      color: #f1f5f9;
    }

    .help { color: var(--muted); font-size: 12px; line-height: 1.5; }

    textarea {
      width: 100%;
      height: 100%;
      resize: none;
      padding: 14px 14px 18px 14px;
      border-radius: 16px;
      border: 1px solid #1f2a44;
      background: linear-gradient(180deg, #0c1425, #0b1220);
      color: var(--text);
      outline: none;
      box-shadow: var(--shadow);
      line-height: 1.6;
      caret-color: var(--accent);
      tab-size: 2;
    }

    .right {
      position: relative;
      border-radius: 16px;
      background: linear-gradient(180deg, #0c1425, #0b1220);
      border: 1px solid #1f2a44;
      overflow: hidden;
      box-shadow: var(--shadow);
      cursor: grab;
    }
    .right:active { cursor: grabbing; }

    .canvas {
      position: relative;
      min-width: 100%;
      min-height: 100%;
      transform-origin: 0 0;
    }

    .node {
      position: absolute;
      width: var(--node-w);
      max-width: var(--node-w);
      padding: 10px 12px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      color: #0b1220;
      font-weight: 600;
      line-height: 1.45;
      word-wrap: break-word;
      overflow-wrap: anywhere;
      transition: transform .12s ease, opacity .3s ease;
    }
    .node:hover { transform: translateY(-1px) scale(1.01); }
    .node.presentation-clickable { cursor: pointer; }

    .svg-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap; /* Cho phép các nút xuống dòng nếu không đủ không gian */
    }

    .btn {
      background: #0a1222;
      color: var(--text);
      border: 1px solid #1f2a44;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .btn:hover{ border-color:#2a3b63 }
    .btn.active {
        background-color: var(--accent);
        color: var(--bg);
        border-color: var(--accent);
    }

    #panel-toggle-btn {
        position: fixed;
        top: 20px;
        left: calc(var(--left-panel-width) + 4px);
        z-index: 100;
        width: 28px;
        height: 28px;
        background: #1f2937;
        color: var(--text);
        border: 1px solid #2a3b63;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        transition: left 0.4s ease, transform 0.3s ease;
    }

    .app.panel-closed + #panel-toggle-btn {
        left: 10px;
        transform: scaleX(-1);
    }

    @media (max-width: 1000px) {
      .app { grid-template-columns: 1fr; height: auto; }
      .right { height: 70vh; }
      #panel-toggle-btn { display: none; }
    }
  </style>
</head>
<body>
  <div class="app" id="app-container">
    <div class="left">
      <div class="toolbar">
        <h1>Mindmap từ văn bản</h1>
        <button class="btn" id="btnDownload">Tải Mindmap</button>
        <button class="btn" id="btnImport">Nhập Mindmap</button>
        <button class="btn" id="btnPresent">Thuyết trình</button>
        <input type="file" id="fileInput" accept=".txt" style="display: none;">
      </div>
      <div class="help">
        • Mỗi <b>dòng</b> là một nút. Số <b>dấu cách đầu dòng</b> = cấp độ.<br/>
        • Gõ / xóa: sơ đồ <b>cập nhật ngay</b>. Dùng <kbd>Tab</kbd> để thụt đầu dòng.<br/>
        • Lăn chuột để <b>phóng to/thu nhỏ</b>, kéo chuột để <b>di chuyển</b>.<br/>
      </div>
      <textarea id="editor" spellcheck="false" placeholder="Nhập nội dung ở đây...\nVí dụ:\nChủ đề\n  Nhánh 1\n    Ý 1.1\n    Ý 1.2\n  Nhánh 2\n    Ý 2.1\n      Chi tiết 2.1.1\n  Nhánh 3">Học Tiếng Anh
  Học Ngữ Pháp
    Thì Hiện tại đơn
    Thì Quá khứ đơn
  Học Từ Vựng
    Chủ đề Gia đình
    Chủ đề Công việc
  Học Phát Âm
    Nguyên âm
    Phụ âm</textarea>
    </div>

    <div class="right" id="viewport">
      <div class="canvas" id="canvas">
        <svg class="svg-layer" id="wires"></svg>
      </div>
    </div>
  </div>

  <button id="panel-toggle-btn">«</button>

  <script>
    const editor = document.getElementById('editor');
    const canvas = document.getElementById('canvas');
    const wires = document.getElementById('wires');
    const viewport = document.getElementById('viewport');
    const btnDownload = document.getElementById('btnDownload');
    const btnImport = document.getElementById('btnImport');
    const fileInput = document.getElementById('fileInput');
    const btnPresent = document.getElementById('btnPresent');

    const appContainer = document.getElementById('app-container');
    const panelToggleBtn = document.getElementById('panel-toggle-btn');

    let scale = 1, panX = 40, panY = 40;
    let isPanning = false, startPanX = 0, startPanY = 0;
    let presentationMode = false;
    let mindmapTree = {};

    panelToggleBtn.addEventListener('click', () => {
        appContainer.classList.toggle('panel-closed');
    });

    btnPresent.addEventListener('click', () => {
        presentationMode = !presentationMode;
        btnPresent.classList.toggle('active', presentationMode);
        
        function setVisibility(node, level) {
            if (presentationMode) {
                node.isVisible = level <= 0;
            } else {
                node.isVisible = true;
            }
            node.children.forEach(child => setVisibility(child, level + 1));
        }
        setVisibility(mindmapTree, -1);
        triggerUpdate(false);
    });

    function applyTransform() {
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    viewport.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      const mouseBeforeZoomX = (mouseX - panX) / scale;
      const mouseBeforeZoomY = (mouseY - panY) / scale;
      
      const delta = -e.deltaY * 0.001;
      const newScale = Math.max(0.2, Math.min(3, scale + delta));
      
      panX = mouseX - mouseBeforeZoomX * newScale;
      panY = mouseY - mouseBeforeZoomY * newScale;
      scale = newScale;
      
      applyTransform();
    });

    viewport.addEventListener('mousedown', (e) => {
        if (e.target !== viewport && e.target !== canvas) return;
        if (e.button !== 0) return;
        isPanning = true;
        startPanX = e.clientX - panX;
        startPanY = e.clientY - panY;
        viewport.style.cursor = 'grabbing';
    });

    window.addEventListener('mouseup', () => {
        isPanning = false;
        viewport.style.cursor = 'grab';
    });
    
    window.addEventListener('mousemove', (e) => {
        if (isPanning) {
            panX = e.clientX - startPanX;
            panY = e.clientY - startPanY;
            applyTransform();
        }
    });

    editor.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const val = editor.value;
        editor.value = val.substring(0, start) + '  ' + val.substring(end);
        editor.selectionStart = editor.selectionEnd = start + 2;
        triggerUpdate();
      }
    });

    btnDownload.addEventListener('click', () => {
        const text = editor.value;
        const blob = new Blob([text], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'mindmap.txt';
        a.click();
        URL.revokeObjectURL(a.href);
    });

    btnImport.addEventListener('click', () => {
        fileInput.click();
    });

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            editor.value = event.target.result;
            triggerUpdate();
        };
        reader.readAsText(file);
        fileInput.value = '';
    });

    function parseLines(text){
      return text.split(/\r?\n/)
        .map((raw, idx) => {
          const match = raw.match(/^(\s*)(.*)$/);
          const indent = match ? match[1] : '';
          const content = match ? match[2] : raw;
          const spaces = indent.replace(/\t/g, '  ');
          const level = Math.floor(spaces.length / 2);
          return { id: idx, level, text: content.trim(), raw };
        })
        .filter(n => n.text.length > 0);
    }

    function buildTree(nodes){
      const root = { id: 'root', level: -1, text: 'ROOT', children: [], isVisible: true };
      const stack = [root];
      nodes.forEach(n => {
        while (stack.length && stack[stack.length-1].level >= n.level) stack.pop();
        const parent = stack[stack.length-1] || root;
        const node = { ...n, children: [], isVisible: !presentationMode || n.level === 0 };
        parent.children.push(node);
        stack.push(node);
      });
      return root;
    }
    
    function layoutTree(root){
      const colWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-w')) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--col-gap'));
      const rowGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--row-gap'));
      const positions = new Map();
      const levelHeights = new Map();

      function calculateY(node, currentY) {
          const nodeHeight = 20 + Math.ceil(node.text.length / 25) * 24 + 10;
          let y = currentY;
          if (levelHeights.has(node.level) && levelHeights.get(node.level) > y) {
              y = levelHeights.get(node.level);
          }
          const x = node.level * colWidth;
          positions.set(node.id, { x, y, w: 220, h: nodeHeight });
          
          let childY = y;
          const visibleChildren = node.children.filter(c => c.isVisible);
          
          if (visibleChildren.length > 1) {
            const childrenHeight = visibleChildren.reduce((acc, child) => acc + (20 + Math.ceil(child.text.length / 25) * 24 + 10) + rowGap, 0) - rowGap;
            const parentPos = positions.get(node.id);
            parentPos.y = y + childrenHeight / 2 - parentPos.h / 2;
            positions.set(node.id, parentPos);
          }
          for (const child of visibleChildren) {
              childY = calculateY(child, childY);
          }
          const newY = childY > y ? childY : y + nodeHeight + rowGap;
          levelHeights.set(node.level, newY);
          return newY;
      }
      
      let currentY = 0;
      const visibleRootChildren = root.children.filter(c => c.isVisible);
      for(const child of visibleRootChildren){
          currentY = calculateY(child, currentY);
      }
      let maxX = 0, maxY = 0;
      positions.forEach(p => { 
        maxX = Math.max(maxX, p.x + p.w); 
        maxY = Math.max(maxY, p.y + p.h); 
      });
      return { positions, width: maxX + colWidth, height: maxY + rowGap * 2 };
    }
    
    // Bảng màu Pastel/Nhạt
    const BASE_HUES = [190, 340, 45, 270, 140, 75];

    // === HÀM ĐÃ THAY ĐỔI ===
    function hslForLevel(level, branchIndex){
      const hue = BASE_HUES[branchIndex % BASE_HUES.length];
      let sat = 90;
      let light;

      if (level === 0) { // Nút gốc
        light = 92; // Rất nhạt
        sat = 85;
      } else if (level === 1) { // Các nhánh chính
        light = 82; // Nhạt và sáng
      } else { // Các nhánh con (cấp 2 trở đi)
        // Bắt đầu từ độ sáng của nhánh chính (82) và làm nó tối đi
        light = 82 - (level - 1) * 15;
        // Đảm bảo không quá tối
        light = Math.max(50, light);
      }
      return `hsl(${hue} ${sat}% ${light}%)`;
    }
    
    // === HÀM ĐÃ THAY ĐỔI ===
    function draw(root, layout){
      const { positions, width, height } = layout;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      wires.setAttribute('width', width);
      wires.setAttribute('height', height);
      wires.setAttribute('viewBox', `0 0 ${width} ${height}`);
      wires.innerHTML = '';
      const fragment = document.createDocumentFragment();
      [...canvas.querySelectorAll('.node')].forEach(n => n.remove());

      function render(node, parent, branchIndex){
        if (node.id === 'root') {
             node.children.forEach((child, index) => render(child, node, index));
             return;
        }

        if (!node.isVisible) return;

        const p = positions.get(node.id);
        const el = document.createElement('div');
        el.className = 'node';
        el.style.left = p.x + 'px';
        el.style.top = p.y + 'px';
        el.style.height = p.h + 'px';
        el.style.background = hslForLevel(node.level, branchIndex);
        el.textContent = node.text;
        
        // === PHẦN MỚI: TÙY CHỈNH NÚT GỐC ===
        if (node.level === 0) {
            el.style.fontSize = '17px';
            el.style.fontWeight = '800';
            el.style.color = '#050a14'; // Màu chữ tối hơn để dễ đọc trên nền sáng
        }
        // === KẾT THÚC PHẦN MỚI ===

        if (presentationMode && node.children.some(c => !c.isVisible)) {
            el.classList.add('presentation-clickable');
            el.onclick = () => {
                node.children.forEach(child => child.isVisible = true);
                triggerUpdate(false);
            };
        }

        fragment.appendChild(el);
        
        if (parent && parent.id !== 'root' && parent.isVisible){
          const a = positions.get(parent.id);
          const x1 = a.x + a.w;
          const y1 = a.y + a.h / 2;
          const x2 = p.x;
          const y2 = p.y + p.h / 2;
          const dx = Math.max(40, (x2 - x1) / 2);
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', 'rgba(148,163,184,.6)');
          path.setAttribute('stroke-width', '2');
          path.setAttribute('stroke-linecap', 'round');
          wires.appendChild(path);
        }
        node.children.forEach(child => render(child, node, branchIndex));
      }
      render(root, null, 0);
      canvas.insertBefore(fragment, wires);
    }

    let raf;
    function triggerUpdate(reparse = true){
      if (raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        if (reparse) {
            const nodes = parseLines(editor.value);
            mindmapTree = buildTree(nodes);
        }
        const layout = layoutTree(mindmapTree);
        draw(mindmapTree, layout);
      });
    }

    editor.addEventListener('input', () => triggerUpdate());

    applyTransform();
    triggerUpdate();
  </script>
</body>
</html>
