<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mindmap từ văn bản – Chế độ Thuyết trình</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #0f172a;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --node-w: 220px;
      --node-h: auto;
      --col-gap: 120px; /* khoảng cách ngang giữa các cấp */
      --row-gap: 28px;  /* khoảng cách dọc tối thiểu giữa các nút */
      --radius: 14px;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
      --left-panel-width: 420px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, #1f2937 0%, var(--bg) 60%);
      color: var(--text);
    }

    .app {
      display: grid;
      grid-template-columns: var(--left-panel-width) 1fr;
      gap: 16px;
      height: 100vh;
      padding: 16px;
      transition: grid-template-columns 0.4s ease;
    }

    .left {
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: transform 0.4s ease, opacity 0.3s ease;
      position: relative;
    }

    .app.panel-closed {
      grid-template-columns: 0px 1fr;
    }
    .app.panel-closed .left {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }

    h1 {
      font-size: 18px;
      margin: 0 0 2px 0;
      font-weight: 650;
      letter-spacing: .2px;
      color: #f1f5f9;
    }

    .help { color: var(--muted); font-size: 12px; line-height: 1.5; }

    textarea {
      width: 100%;
      height: 100%;
      resize: none;
      padding: 14px 14px 18px 14px;
      border-radius: 16px;
      border: 1px solid #1f2a44;
      background: linear-gradient(180deg, #0c1425, #0b1220);
      color: var(--text);
      outline: none;
      box-shadow: var(--shadow);
      line-height: 1.6;
      caret-color: var(--accent);
      tab-size: 2;
    }

    .right {
      position: relative;
      border-radius: 16px;
      background: linear-gradient(180deg, #0c1425, #0b1220);
      border: 1px solid #1f2a44;
      overflow: hidden;
      box-shadow: var(--shadow);
      cursor: grab;
    }
    .right:active { cursor: grabbing; }

    .canvas {
      position: relative;
      min-width: 100%;
      min-height: 100%;
      transform-origin: 0 0;
    }

    .node {
      position: absolute;
      width: var(--node-w);
      max-width: var(--node-w);
      padding: 10px 12px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      color: #1c1c1c; /* Đổi màu chữ mặc định thành màu tối để dễ đọc trên nền sáng */
      font-weight: 600;
      line-height: 1.45;
      word-wrap: break-word;
      overflow-wrap: anywhere;
      transition: transform .12s ease, opacity .3s ease, background .3s ease;
    }
    .node:hover { transform: translateY(-1px) scale(1.01); }
    .node.presentation-clickable { cursor: pointer; }

    .svg-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn {
      background: #0a1222;
      color: var(--text);
      border: 1px solid #1f2a44;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .btn:hover{ border-color:#2a3b63 }
    .btn.active {
        background-color: var(--accent);
        color: var(--bg);
        border-color: var(--accent);
    }

    #panel-toggle-btn {
        position: fixed;
        top: 20px;
        left: calc(var(--left-panel-width) + 4px);
        z-index: 100;
        width: 28px;
        height: 28px;
        background: #1f2937;
        color: var(--text);
        border: 1px solid #2a3b63;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        transition: left 0.4s ease, transform 0.3s ease;
    }

    .app.panel-closed + #panel-toggle-btn {
        left: 10px;
        transform: scaleX(-1);
    }

    @media (max-width: 1000px) {
      .app { grid-template-columns: 1fr; height: auto; }
      .right { height: 70vh; }
      #panel-toggle-btn { display: none; }
    }
  </style>
</head>
<body>
  <div class="app" id="app-container">
    <div class="left">
      <div class="toolbar">
        <h1>Mindmap từ văn bản</h1>
        <button class="btn" id="btnDownload">Tải Mindmap</button>
        <button class="btn" id="btnImport">Nhập Mindmap</button>
        <button class="btn" id="btnPresent">Thuyết trình</button>
        <input type="file" id="fileInput" accept=".txt" style="display: none;">
      </div>
      <div class="help">
        • Mỗi <b>dòng</b> là một nút. Số <b>dấu cách đầu dòng</b> = cấp độ.<br/>
        • Gõ / xóa: sơ đồ <b>cập nhật ngay</b>. Dùng <kbd>Tab</kbd> để thụt đầu dòng.<br/>
        • Lăn chuột để <b>phóng to/thu nhỏ</b>, kéo chuột để <b>di chuyển</b>.<br/>
      </div>
      <textarea id="editor" spellcheck="false" placeholder="Nhập nội dung ở đây...\nVí dụ:\nChủ đề\n  Nhánh 1\n    Ý 1.1\n    Ý 1.2\n  Nhánh 2\n    Ý 2.1\n      Chi tiết 2.1.1\n  Nhánh 3">Học Tiếng Anh
  Học Ngữ Pháp
    Thì Hiện tại đơn
    Thì Quá khứ đơn
      Chi tiết thì
  Học Từ Vựng
    Chủ đề Gia đình
    Chủ đề Công việc
  Học Phát Âm
    Nguyên âm
    Phụ âm</textarea>
    </div>

    <div class="right" id="viewport">
      <div class="canvas" id="canvas">
        <svg class="svg-layer" id="wires"></svg>
      </div>
    </div>
  </div>

  <button id="panel-toggle-btn">«</button>

  <script>
    const editor = document.getElementById('editor');
    const canvas = document.getElementById('canvas');
    const wires = document.getElementById('wires');
    const viewport = document.getElementById('viewport');
    const btnDownload = document.getElementById('btnDownload');
    const btnImport = document.getElementById('btnImport');
    const fileInput = document.getElementById('fileInput');
    const btnPresent = document.getElementById('btnPresent');
    const appContainer = document.getElementById('app-container');
    const panelToggleBtn = document.getElementById('panel-toggle-btn');

    const ROOT_NODE_PALETTE = ['#d586f4', '#c3e9cc', '#f3a88f', '#a6abe7', '#eedc96', '#f6f3ce', '#aae496'];
    
    // === BẢNG MÀU ĐÃ ĐƯỢC SẮP XẾP LẠI THEO ĐÚNG YÊU CẦU CỦA BẠN ===
    // 1. Học Ngữ Pháp -> #B0E0E6 (Powder Blue)
    // 2. Học Từ Vựng  -> #D8BFD8 (Thistle)
    // 3. Học Phát Âm  -> #FFFACD (Lemon Chiffon)
    const MAIN_BRANCH_PALETTE = [
        '#B0E0E6', // Dành cho "Học Ngữ Pháp"
        '#D8BFD8', // Dành cho "Học Từ Vựng"
        '#FFFACD', // Dành cho "Học Phát Âm"
        '#FAFAD2', '#FFDAB9', '#AAF0D1', '#EEDFCC', '#FFF5E1' // Các màu còn lại dự phòng
    ];

    let scale = 1, panX = 40, panY = 40;
    let isPanning = false, startPanX = 0, startPanY = 0;
    let presentationMode = false;
    let mindmapTree = {};
    let rootNodeColor = ROOT_NODE_PALETTE[0];

    function hexToHsl(hex) {
      if (!hex) return null;
      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!result) return null;

      let r = parseInt(result[1], 16) / 255;
      let g = parseInt(result[2], 16) / 255;
      let b = parseInt(result[3], 16) / 255;
      
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max == min) {
        h = s = 0;
      } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return { h: h * 360, s: s, l: l };
    }

    function getNodeColor(level, branchIndex) {
        if (level === 0) {
            return rootNodeColor;
        }

        const baseHexColor = MAIN_BRANCH_PALETTE[branchIndex % MAIN_BRANCH_PALETTE.length];

        if (level === 1) {
            return baseHexColor;
        }

        const baseHsl = hexToHsl(baseHexColor);
        if (!baseHsl) return '#CCCCCC';

        let newLightness = baseHsl.l * 100 - (level - 1) * 8;
        newLightness = Math.max(30, newLightness);

        return `hsl(${baseHsl.h}, ${baseHsl.s * 100}%, ${newLightness}%)`;
    }

    panelToggleBtn.addEventListener('click', () => appContainer.classList.toggle('panel-closed'));

    btnPresent.addEventListener('click', () => {
        presentationMode = !presentationMode;
        btnPresent.classList.toggle('active', presentationMode);
        
        function setVisibility(node, level) {
            if (presentationMode) node.isVisible = level <= 0;
            else node.isVisible = true;
            node.children.forEach(child => setVisibility(child, level + 1));
        }
        setVisibility(mindmapTree, -1);
        triggerUpdate(false);
    });

    function applyTransform() {
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    viewport.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const mouseBeforeZoomX = (mouseX - panX) / scale;
      const mouseBeforeZoomY = (mouseY - panY) / scale;
      const delta = -e.deltaY * 0.001;
      const newScale = Math.max(0.2, Math.min(3, scale + delta));
      panX = mouseX - mouseBeforeZoomX * newScale;
      panY = mouseY - mouseBeforeZoomY * newScale;
      scale = newScale;
      applyTransform();
    });

    viewport.addEventListener('mousedown', (e) => {
        if (e.target !== viewport && e.target !== canvas) return;
        if (e.button !== 0) return;
        isPanning = true;
        startPanX = e.clientX - panX;
        startPanY = e.clientY - panY;
        viewport.style.cursor = 'grabbing';
    });
    
    window.addEventListener('mouseup', () => { isPanning = false; viewport.style.cursor = 'grab'; });
    window.addEventListener('mousemove', (e) => {
        if (isPanning) {
            panX = e.clientX - startPanX;
            panY = e.clientY - startPanY;
            applyTransform();
        }
    });

    editor.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = editor.selectionStart, end = editor.selectionEnd;
        editor.value = editor.value.substring(0, start) + '  ' + editor.value.substring(end);
        editor.selectionStart = editor.selectionEnd = start + 2;
        triggerUpdate();
      }
    });

    btnDownload.addEventListener('click', () => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([editor.value], { type: 'text/plain' }));
        a.download = 'mindmap.txt';
        a.click();
        URL.revokeObjectURL(a.href);
    });

    btnImport.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => { editor.value = event.target.result; triggerUpdate(); };
        reader.readAsText(file);
        fileInput.value = '';
    });

    function parseLines(text){
      return text.split(/\r?\n/)
        .map((raw, idx) => {
          const match = raw.match(/^(\s*)(.*)$/);
          const level = Math.floor((match ? match[1] : '').replace(/\t/g, '  ').length / 2);
          const content = (match ? match[2] : raw).trim();
          return { id: idx, level, text: content };
        })
        .filter(n => n.text.length > 0);
    }

    function buildTree(nodes){
      const root = { id: 'root', level: -1, children: [], isVisible: true };
      const stack = [root];
      nodes.forEach(n => {
        while (stack.length && stack[stack.length-1].level >= n.level) stack.pop();
        const parent = stack[stack.length-1] || root;
        const node = { ...n, children: [], isVisible: !presentationMode || n.level === 0 };
        parent.children.push(node);
        stack.push(node);
      });
      return root;
    }
    
    function layoutTree(root){
      const colWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--node-w')) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--col-gap'));
      const rowGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--row-gap'));
      const positions = new Map();
      const levelHeights = new Map();

      function calculateY(node, currentY) {
          const nodeHeight = 20 + Math.ceil(node.text.length / 25) * 24 + 10;
          let y = currentY;
          if (levelHeights.has(node.level) && levelHeights.get(node.level) > y) y = levelHeights.get(node.level);
          positions.set(node.id, { x: node.level * colWidth, y, w: 220, h: nodeHeight });
          
          let childY = y;
          const visibleChildren = node.children.filter(c => c.isVisible);
          
          if (visibleChildren.length > 1) {
            const childrenHeight = visibleChildren.reduce((acc, child) => acc + (20 + Math.ceil(child.text.length / 25) * 24 + 10) + rowGap, 0) - rowGap;
            const parentPos = positions.get(node.id);
            parentPos.y = y + childrenHeight / 2 - parentPos.h / 2;
            positions.set(node.id, parentPos);
          }
          for (const child of visibleChildren) childY = calculateY(child, childY);
          const newY = childY > y ? childY : y + nodeHeight + rowGap;
          levelHeights.set(node.level, newY);
          return newY;
      }
      
      let currentY = 0;
      for(const child of root.children.filter(c => c.isVisible)) currentY = calculateY(child, currentY);
      let maxX = 0, maxY = 0;
      positions.forEach(p => { 
        maxX = Math.max(maxX, p.x + p.w); 
        maxY = Math.max(maxY, p.y + p.h); 
      });
      return { positions, width: maxX + colWidth, height: maxY + rowGap * 2 };
    }
    
    function draw(root, layout){
      const { positions, width, height } = layout;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      wires.setAttribute('width', width);
      wires.setAttribute('height', height);
      wires.setAttribute('viewBox', `0 0 ${width} ${height}`);
      wires.innerHTML = '';
      const fragment = document.createDocumentFragment();
      [...canvas.querySelectorAll('.node')].forEach(n => n.remove());

      function render(node, parent, branchIndex){
        if (node.id === 'root') {
             node.children.forEach((child, index) => render(child, node, index));
             return;
        }
        if (!node.isVisible) return;

        const p = positions.get(node.id);
        const el = document.createElement('div');
        el.className = 'node';
        el.style.left = p.x + 'px';
        el.style.top = p.y + 'px';
        el.style.height = p.h + 'px';
        el.style.background = getNodeColor(node.level, branchIndex);
        el.textContent = node.text;
        
        if (node.level === 0) {
            el.style.fontSize = '18px';
            el.style.fontWeight = '900';
            el.style.color = '#101010';
        }

        if (presentationMode && node.children.some(c => !c.isVisible)) {
            el.classList.add('presentation-clickable');
            el.onclick = () => { node.children.forEach(c => c.isVisible = true); triggerUpdate(false); };
        }
        fragment.appendChild(el);
        if (parent && parent.id !== 'root' && parent.isVisible){
          const a = positions.get(parent.id);
          const p_pos = positions.get(node.id);
          const [x1, y1, x2, y2] = [a.x + a.w, a.y + a.h / 2, p_pos.x, p_pos.y + p_pos.h / 2];
          const dx = Math.max(40, (x2 - x1) / 2);
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke', 'rgba(148,163,184,.6)');
          path.setAttribute('stroke-width', '2');
          path.setAttribute('stroke-linecap', 'round');
          wires.appendChild(path);
        }
        node.children.forEach(child => render(child, node, branchIndex));
      }
      render(root, null, 0);
      canvas.insertBefore(fragment, wires);
    }

    let raf;
    function triggerUpdate(reparse = true){
      if (raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        if (reparse) {
            const nodes = parseLines(editor.value);
            mindmapTree = buildTree(nodes);
            rootNodeColor = ROOT_NODE_PALETTE[Math.floor(Math.random() * ROOT_NODE_PALETTE.length)];
        }
        const layout = layoutTree(mindmapTree);
        draw(mindmapTree, layout);
      });
    }

    editor.addEventListener('input', () => triggerUpdate());
    applyTransform();
    triggerUpdate();
  </script>
</body>
</html>
